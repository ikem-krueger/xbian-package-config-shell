#!/bin/bash

#
#Copyright 2012 - 2017 CurlyMo & mkreisl <development@xbian.org>
#
#This file is part of XBian - XBMC on the Raspberry Pi.
#
#XBian is free software: you can redistribute it and/or modify it under the
#terms of the GNU General Public License as published by the Free Software
#Foundation, either version 3 of the License, or (at your option) any later
#version.
#
#XBian is distributed in the hope that it will be useful, but WITHOUT ANY
#WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
#FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#details.
#
#You should have received a copy of the GNU General Public License along
#with XBian. If not, see <http://www.gnu.org/licenses/>

# The arguments this module accepts
ARGUMENTS=(start status imgplan imgdest imgtype imgkeep homestart homestatus homeplan homedest homekeep doclean getpart dodaily doweekly domonthly);

#|------------------------------------|
#|          Include files             |
#|------------------------------------|

source $BASEPATH/modules/xbiancopy/functions
if [ $GUIMODE -eq 1 ]; then
	source $BASEPATH/modules/xbiancopy/dialogs;
fi

#|------------------------------------|
#|          Global variables          |
#|------------------------------------|

#|------------------------------------|
#|           Main program             |
#|------------------------------------|

# Executes the GUI version of this module
function showGUIFn() {
        tm=$(mktemp -d)
        cleanup () {
            mountpoint -q $tm && umount $tm 2>/dev/null; rmdir $tm 2>/dev/null; rm -f /run/f.txt
            [ -e /etc/default/xbian-initramfs.xc ] && mv /etc/default/xbian-initramfs.xc /etc/default/xbian-initramfs
        }
        trap 'cd /; cleanup' RETURN EXIT TERM

        showConfigDialog
        if [ $? -eq 0 ]; then
            opt_img=''
            IFS=$'\n';
            DATA=($(echo -e "$RETURN"));
            IFS=$ORIGINALIFS;
            DEST=${DATA[1]}; 

            if echo "$DEST" | grep -q ^'nfs[34]*:'; then
                tt=${DEST%%:*}; tt=${tt#*nfs}
                DEST=${DEST#*:}
                case $tt in
                    3) service portmap start &>/dev/null; bo=",vers=$tt"; mo="-o vers=$tt"; to='--acls --xattrs' ;;
                    4) bo=",vers=$tt"; mo="-o vers=$tt"; to='' ;;
                    *) service portmap status | grep -q running && { bo=''; mo='-o vers=3'; to='--acls --xattrs'; } || { bo=''; mo=''; to=''; } ;;
                esac
                mount $DEST $mo $tm && { rm -fr $tm/root~ $tm/xbian~ || :; } && touch $tm/root~ && touch $tm/xbian~ && chown xbian:xbian $tm/xbian~ && \
                    [ "$(stat -c %U $tm/root~)" = root -a "$(stat -c %U $tm/xbian~)" = xbian ] || \
                        { showNFSerror; sleep 5; umount -l $tm 2>/dev/null; rmdir $tm 2>/dev/null; return 1; }

                tt=nfs
            elif echo "$DEST" | grep -q ^'f2fs:'; then
                DEST=${DEST##'f2fs:'}
                tt=f2fs
            elif echo "$DEST" | grep -q ^'ext4:'; then
                DEST=${DEST##'ext4:'}
                tt=ext4
            else 
                echo "$DEST" | grep -q ^'file:' && opt_img='--img'
                DEST=${DEST##'file:'}
                tt=btrfs
            fi
            # check for block device
            if [ -z "$opt_img" -a "$tt" != nfs ]; then
                { [ -b $DEST ] && echo $DEST | grep -q ".*[0-9]$"; } || { showWrongBlockDev; sleep 5; return 1; }
                if [ "$tt" != btrfs ]; then
                     { ! mountpoint -q $DEST || umount $DEST; } && mkfs.$tt $DEST >/dev/null 2>&1 && mount -t $tt $DEST $tm || { showUmountFormatError; sleep 5; return 1; }
                fi
            fi

            # copy data
            case $tt in
                btrfs)
                    btrfs-auto-snapshot xbiancopy $opt_img ${DATA[0]} "$DEST"
                    ;;
                nfs|f2fs|ext4)
                    rm -frv $tm/ 2>/dev/null | sed "s%$tm%%g" | dialog --progressbox "Wiping out $DEST ..." 8 70 || :
                    dirs=$(echo $(sed 's/^[ \t]*//;/^#/d;/subvol=/!d' /etc/fstab | awk '{ print $2 }')" / /home/xbian /home/xbian/.kodi" | tr " " "\n" | sort -u | tr "\n" " ")
                    for d in $dirs; do
                        mountpoint -q $d && mkdir -p $tm/$d && ar=0 && ( cd $tm/; tar c --one-file-system $to $d | pv -n -s $(du -sbx $d | awk '{print $1}') | \
                            tar x $to -v >/run/f.txt) 2>&1 | \
                                while read a; do
                                    if echo "$a" | grep -qv ^tar; then
                                        (( $a >= $ar )) && ar=$a
                                        printf "XXX\n$ar\n$(printf "%-.66s" $(tail -1 /run/f.txt))\nXXX\n"
                                    fi
                                done | dialog --gauge "Copying $d ..." 8 70
                    done
                    sed -i '/.*subvol=/s/^/#/;/.*[ \t]\/[ \t]/s/^/#/' $tm/etc/fstab
                    ;;
                *)
                    ;;
            esac

            # update /boot
            case $tt in
                nfs)
                    getused() {
                         local h=''
                         for n in $(ip addr | grep state | grep -vwE 'lo|dummy[0-9]|tun[0-9]' | awk '{ sub(":","",$2); print $2; }'); do
                             [ x"$(ip a show $n | sed -n -e 's/:127\.0\.0\.1 //g' -e 's/ *inet \([0-9.]\+\).*/\1/gp')" = x"$1" ] && h=$n" $h"
                         done
                         echo $h
                    }
                    nd=$(getused $(netstat -nt 2>/dev/null | grep -m1 $(findmnt -n ${tm} | awk '{ sub(".*,addr=",""); sub(",.*",""); print $0; }'):2049 | \
                        awk '{ split($4, a, ":"); print a[1]; }'))
                    if grep -q "iface $nd inet static" /etc/network/interfaces; then
                        nc=$(grep -A10 "iface $nd inet static" /etc/network/interfaces)
                        ip=$(echo "$nc" | grep -m1 address | awk '{ print $2 }')
                        nm=$(echo "$nc" | grep -m1 netmask | awk '{ print $2 }')
                        gw=$(echo "$nc" | grep -m1 gateway | awk '{ print $2 }')
                        nc="cnet=$ip::$gw:$nm::$nd:off"
                    else
                        lsmod | grep -q ^smsc95xx && nc="cnet=$nd" || nc="ip=$nd"
                    fi
                    if [ -e /boot/cmdline.txt ]; then
                        cmd=$(tr " " "\n" < /boot/cmdline.txt | grep -vE 'rootfstype=|root=|rootflags=|nfsroot=|ip=|cnet=')
                        cmd="root=/dev/nfs nfsroot=$DEST,tcp$bo rootfstype=nfs $nc $cmd"
                        [ -e /boot/cmdline.txt.nfs ] || mv /boot/cmdline.txt /boot/cmdline.txt.nfs
                        echo "$cmd" | tr "\n" " " | sed 's/$/&\n/' > /boot/cmdline.txt
                    fi
                    if [ -e /boot/boot.scr.txt ]; then
                        cmd=$(grep '^setenv baseconfig .* root=' /boot/boot.scr.txt | sed "s%setenv baseconfig %%g" | tr " " "\n" | grep -vE 'rootfstype=|root=|rootflags=|nfsroot=|ip=|cnet=')
                        cmd=$(echo "root=/dev/nfs nfsroot=$DEST,tcp$bo rootfstype=nfs $nc $cmd" | tr "\n" " ")
                        [ -e /boot/boot.scr.txt.nfs ] || cp -a /boot/boot.scr.txt /boot/boot.scr.txt.nfs
                        sed -i "s%^setenv baseconfig .*%setenv baseconfig $cmd%g" /boot/boot.scr.txt
                        ( cd /boot; ./mks; ) &>/dev/null
                    fi
                    /etc/xbian-initramfs/initram.switcher.sh update
                    case $nd in
                        wlan*|ra*)
                            if ! grep -q 'LAN=yes' /etc/default/xbian-initramfs; then
                                cp -a /etc/default/xbian-initramfs /etc/default/xbian-initramfs.xc
                                sed -i 's/LAN=.*/LAN=yes/g' /etc/default/xbian-initramfs
                                sed -i 's/LAN=.*/LAN=yes/g' $tm/etc/default/xbian-initramfs
                                xbian-update-initramfs | dialog --progressbox "Rebuilding initramfs ..." 8 70 || :
                            fi
                        ;;
                    esac
                    ;;
                *)
                    ;;
            esac

        fi
}

# Executes the command line version of this module
#  $1 Argument [String]
# status | start source destination [fs label] [[size]]
#  (for size, human readable symbols are accepted (800M, 1G, 1T...)
#
# status return code
# 1 ready
# 0 running
# -1 failed
# -2 not started
# 
# start return code
# number - pid of started backup process
# -1 failed
# -3 already running 

function showCMDFn() {
    case $1 in
        start)
            [ "$(xbian-config xbiancopy status)" -eq 0 ] && { echo "-3"; exit 0; }
            [ $# -lt 3 ] && { echo "-1"; exit 5; }
            # [ -n "$4" ] && lab="--label  
            [ -n "$5" ] && size="--size"
            echo "$3" | grep -q ^'file:' && opt_img='--img'
            dest="$3" && dest=${dest##'file:'}
            echo dest=\"$dest\" > /run/xbiancopy.tmp; . /run/xbiancopy.tmp; rm /run/xbiancopy.tmp
            nice -n +1 /usr/sbin/btrfs-auto-snapshot xbiancopy $size $5 $opt_img $2 $dest  > /dev/null 2>&1 & pid=$!
            echo $pid > /tmp/xbiancopy.running
            echo $pid
            ;;
        status)
            [ -e /tmp/xbiancopy.running ] || { echo "-2"; exit 0; }
            if [ -e /tmp/xbiancopy.running.$(cat /tmp/xbiancopy.running) ]; then
                rm -f "/tmp/xbiancopy.running.$(cat /tmp/xbiancopy.running)"
                rm -f /tmp/xbiancopy.running
                echo "1"
            else
                kill -0 $(cat /tmp/xbiancopy.running) > /dev/null 2>&1 || { echo "-1"; rm -f /tmp/xbiancopy.running; exit 0; }
                echo "0"
            fi
            ;;
        homestart)
            [ "$(xbian-config backuphome status)" -eq 0 ] && { echo "-3"; exit 0; }
            nice -n +1 /usr/sbin/btrfs-auto-snapshot backuphome $2 > /dev/null 2>&1 & pid=$!
            echo $pid > /tmp/backuphome.running
            echo $pid
            ;;
        homestatus)
            [ -e /tmp/backuphome.running ] || { echo "-2"; exit 0; }
            if test -e "/xbmc-backup/backuphome.running.$(cat /tmp/backuphome.running)"; then
                rm -f "/xbmc-backup/backuphome.running.$(cat /tmp/backuphome.running)"
                rm -f /tmp/backuphome.running
                echo "1"
            else
                kill -0 $(cat /tmp/backuphome.running) > /dev/null 2>&1 || { echo "-1"; rm -f /tmp/backuphome.running; exit 0; }
                echo "0"
            fi
            ;;
        imgplan)
            echo $(backupImgPlanFn $2)
            ;;
        imgtype)
            echo $(backupImgTypeFn $2)
            ;;
        imgdest)
            echo $(backupImgDestFn $2)
            ;;
        imgkeep)
            echo $(backupImgKeepFn $2)
            ;;
        homeplan)
            echo $(backupHomePlanFn $2)
            ;;
        homedest)
            echo $(backupHomeDestFn $2)
            ;;
        homekeep)
            echo $(backupHomeKeepFn $2)
            ;;
        doclean)
            echo $(backupDoCleanFn $2 $3)
            ;;
        getpart)
            echo $(getImgPartitionsFn)
            ;;
        dodaily)
            echo $(dailySnapFn $2)
            ;;
        doweekly)
            echo $(weeklySnapFn $2)
            ;;
        domonthly)
            echo $(monthlySnapFn $2)
            ;;
    esac

    exit 0
}
