#!/bin/bash

#
#Copyright 2012 - 2017 Hexagon, CurlyMo, mk01 & mkreisl <development@xbian.org>
#
#This file is part of XBian - XBMC on the Raspberry Pi.
#
#XBian is free software: you can redistribute it and/or modify it under the
#terms of the GNU General Public License as published by the Free Software
#Foundation, either version 3 of the License, or (at your option) any later
#version.
#
#XBian is distributed in the hope that it will be useful, but WITHOUT ANY
#WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
#FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#details.
#
#You should have received a copy of the GNU General Public License along
#with XBian. If not, see <http://www.gnu.org/licenses/>

setAuto() {
    case $1 in
        eth?|wlan?|ra?)
            if grep ^auto /etc/network/interfaces > /etc/network/interfaces.new; then
                if ! grep -q ^"auto.*$1" /etc/network/interfaces.new; then
                    sed -i "s%auto %auto $1 %" /etc/network/interfaces.new
                fi
            else
                echo "auto $1 lo" > /etc/network/interfaces.new
            fi
            grep -vi ^auto /etc/network/interfaces >> /etc/network/interfaces.new
            mv /etc/network/interfaces.new /etc/network/interfaces
            ;;
        lo)
            ;;
    esac

    return 0
}

resAuto() {
    case $1 in
        eth?|wlan?|ra?)
            grep ^auto /etc/network/interfaces | sed "s% $1%%" > /etc/network/interfaces.new
            grep -vi ^auto /etc/network/interfaces >> /etc/network/interfaces.new
            mv /etc/network/interfaces.new /etc/network/interfaces
            ;;
        lo)
            ;;
    esac

    return 0
}

setInterfaceDisableFn() {
    case $1 in
        eth?)
            resAuto $1
            ;;
        wlan?|ra?)
            sed -i "s%^allow-hotplug.*$1%#allow-hotplug $1%" /etc/network/interfaces
            sed -i "s%^iface.*$1%#iface $1%" /etc/network/interfaces
            resAuto $1
            ;;
        *)
            ;;
    esac
    ifdown $1 >&/dev/null; ifdown --force $1 >&/dev/null; ip link set dev $1 down >&/dev/null; ip a flush dev $1
    return 1
}

# Set wlan credentials
# Arguments
#  $1 Interface name
#  $2 Protection (WPA|WEP|Open)
#  $3 ESSID
#  $4 WLANKEY (Only needed for WPA and WEP)
# Return
#  1: Success
#  0: Failure
# Error codes
#  -10: Invalid wireless protection
setInterfaceWlanCredentials() {

	# Check that supplied interface is valid
	isValidInterfaceFn "$1"
	if [ $? -eq 1 ]; then

		# Create buffer for holding configuration
		WLANBUFFER=""
		n=$(echo "$3" | sed 's%\\%\\\\%g' )
		k=$(echo "$4" | sed 's%\\%\\\\%g' )
		case $2 in
			"WEP")
				WLANBUFFER+="\n    wireless-essid $n\nnwireless-key $k"
			;;
			"WPA")
				WLANBUFFER+="\n    wpa-ssid $n\nwpa-psk $k"
			;;
			"Open")
				WLANBUFFER+="\n    wireless-mode managed\nwireless-essid $n"
			;;
			*)
				return 2
			;;
		esac

		if [ $(grep -c "^iface $1" /etc/network/interfaces) -gt 0 ]; then

			# Interface already present, store it + any subsequent ifaces in an buffer
			IFACEBUFFER=$(grep -A100 "^iface $1" /etc/network/interfaces | sed '1d');

			# Extract DHCP or Static
			MODE=$(sed -ne "s/\(iface $1 \)\([a-z]\{1,\}\)[\ ]\([a-z]\{1,\}\)/\3/p" /etc/network/interfaces);

			# Remove what's now in the buffer from the file
			sed -i "/^iface $1/,+100d" /etc/network/interfaces

			# Extract subsequent ifaces to a separate buffer
			MORE=$(echo -e "$IFACEBUFFER" | sed -n '/\(allow-hotplug.*\|^iface.*\)/,$p')

			# Get a cleaned verson of current clause
			ME=$(echo -e "$IFACEBUFFER" | sed '/\(allow-hotplug.*\|^iface.*\)/,$d' | sed '/\(^[ \t]*wireless.*\|^[ \t]*wpa.*\)/d')

			# Re-add current interface withouth previous cruft
	                echo -e "iface $1 inet $MODE" >> /etc/network/interfaces
			echo -e "$WLANBUFFER" >> /etc/network/interfaces
			echo -e "$ME\n" >> /etc/network/interfaces

			# Re-add subsequent interfaces
			echo -e "$MORE" >> /etc/network/interfaces

		else
			# Interface not present, add it to the end
			echo -e "iface $1 inet dhcp" >> /etc/network/interfaces
			echo -e "$WLANBUFFER\n" >> /etc/network/interfaces
		fi
		return 1;
	else
		return 3;
	fi
}

# Sets an interface to use dhcp
# Arguments
#  $1 Interface name
setInterfaceDhcpFn() {
	isValidInterfaceFn "$1"
	if [ $? -eq 1 ]; then
		# We have to save current configuration for later (restart interface needs this file for shutting down interface properly)
		cp /etc/network/interfaces /run/interfaces.xbian

		sed -i "s/^#iface $1/iface $1/" /etc/network/interfaces
		sed -i "s/^#allow hotplug $1/allow hotplug $1/" /etc/network/interfaces
		if [ $(grep -c "^iface $1" /etc/network/interfaces) -gt 0 ]; then

			# Interface already present, store it + any subsequent ifaces in an buffer
			IFACEBUFFER=$(grep -A100 "^iface $1" /etc/network/interfaces | sed '1d');

			# Remove what's now in the buffer from the file
			sed -i "/^iface $1/,+100d" /etc/network/interfaces

			# Extract subsequent ifaces to a separate buffer
			MORE=$(echo -e "$IFACEBUFFER" | sed -n '/\(allow-hotplug.*\|^iface.*\)/,$p')

			# Get a cleaned verson of current clause
			ME=$(echo -e "$IFACEBUFFER" | sed '/\(allow-hotplug.*\|^iface.*\)/,$d' | sed '/\(^address.*\|^netmask.*\|^gateway.*\)/d')

			# Re-add current interface withouth previous cruft
	                echo -e "iface $1 inet dhcp" >> /etc/network/interfaces
			echo -e "$ME\n" >> /etc/network/interfaces

			# Re-add subsequent interfaces
			echo -e "$MORE" >> /etc/network/interfaces

		else
			# Interface not present, add it to the end
			case $1 in wlan?|ra?) echo "allow-hotplug $1" >> /etc/network/interfaces; ;; esac
			sudo echo -e "iface $1 inet dhcp\n" >> /etc/network/interfaces

		fi
		sed -i "s%#allow-hotplug.*$1%allow-hotplug $1%" /etc/network/interfaces
		return 1;
	else
		return 0;
	fi
}

# Validate a given ip address
# Arguments
#  $1 IP
#  $2 Netmask
# Return
#  1: Valid
#  0: Invalid
function checkValidIpNumberFn() {
	[ "$(ipcalc $1/$2|grep Address: | awk '{print $2}')" = "$1" ] || return 0
	return 1;
}

function checkIp() {
    ipcalc $1 | grep -q "INVALID ADDRESS" || return 1
    return 0
}

function checkValidGwFn() {
    checkIp "$3" && return 0
    lo=$(echo $(ipcalc -b $1/$2|grep 'Network\|Broadcast' |awk '{print $2}' | awk -F'/' '{print $1}') | awk '{print $1}')
    hi=$(echo $(ipcalc -b $1/$2|grep 'Network\|Broadcast' |awk '{print $2}' | awk -F'/' '{print $1}') | awk '{print $2}')
    [[ "$lo" < "$3" ]] && [[ "$3" < "$hi" ]] || return 0
    return 1 
}


# Validate a given netmask
# Arguments
#  $1 IP
#  $2 Netmask
# Return
#  1: Valid
#  0: Invalid
function checkValidIpNetmaskFn() {
	[ "$(ipcalc $1/$2|grep Netmask: | awk '{print $2}')" = "$2" ] || return 0
	return 1
}

# Sets an interface to use static ip
# Arguments
#  $1 Interface name
#  $2 IP
#  $3 Netmask
#  $4 Gateway (optional)
#  $5 DNS1 (optional)
#  $6 DNS2 (optional)
#  $7 Method static/manual (optional)
# Returns
#  0: Failed
#  1: Success
# Error codes
#  -3: Invalid interface
#  -6: Invalid IP
#  -7: Invalid netmask
#  -8: Invalid Gateway
#  -9: Invalid DNS
setInterfaceStaticFn() {
	isValidInterfaceFn "$1"
	if [ $? -eq 1 ]; then

		# Configuration buffer
		BUFFERIFACES=""
		BUFFERRESOLV=""
		# Validate input & preparation of configuration buffers
		checkValidIpNumberFn "$2" "$3"
		if [ ! $? -eq 1 ]; then
			return 6;
		else
			BUFFERIFACES+="    address $2"
		fi
		checkValidIpNetmaskFn "$2" "$3"
		if [ ! $? -eq 1 ]; then
			return 7;
		else
			BUFFERIFACES+="\n    netmask $3"
		fi
		if [ $# -gt 3 ] && [ -n "$4" ]; then
			if [ "$4" != "None" ] && [ "$4" != "0.0.0.0" ]; then
				checkValidGwFn "$2" "$3" "$4"
				if [ ! $? -eq 1 ]; then
					return 8;
				else
					BUFFERIFACES+="\n    gateway $4"
				fi
			fi
		fi
		if [ $# -gt 4 ] && [ ! -z "$5" ] && [ "$5" != "0.0.0.0" ] && [ "$5" != "None" ]; then
			checkIp "$5"
			if [ ! $? -eq 1 ]; then
				return 9;
			else
				BUFFERRESOLV+="nameserver $5"
			fi
		fi
		if [ $# -gt 5 ] && [ ! -z "$6" ] && [ "$6" != "0.0.0.0" ] && [ "$6" != "None" ]; then
			checkIp "$6"
			if [ ! $? -eq 1 ]; then
				return 9;
			else
				BUFFERRESOLV+="\nnameserver $6"
			fi
		fi

		method=static
		[ $# -gt 6 ] && [ ! -z "$7" ] && method=$7

		# We have to save current configuration for later (restart interface needs this file for shutting down interface properly)
		cp /etc/network/interfaces /run/interfaces.xbian

		sed -i "s/^#iface $1/iface $1/" /etc/network/interfaces
		sed -i "s/^#allow hotplug $1/allow hotplug $1/" /etc/network/interfaces
		# Process /etc/network/interfaces
		if [ $(grep -c "^iface $1" /etc/network/interfaces) -gt 0 ]; then

			# Interface already present, store it + any subsequent ifaces in an buffer
			IFACETMP=$(grep -A100 "^iface $1" /etc/network/interfaces | sed '1d');

			# Remove what's now in the buffer from the file
			sed -i "/^iface $1/,+100d" /etc/network/interfaces

			# Extract subsequent ifaces to a separate buffer
			MORE=$(echo -e "$IFACETMP" | sed -n '/\(allow-hotplug.*\|^iface.*\)/,$p')
			ME=$(echo -e "$IFACETMP" | sed '/\(allow-hotplug.*\|^iface.*\)/,$d' | sed '/\(.*address.*\|.*netmask.*\|.*gateway.*\)/d')

			# Re-add current interface withouth previous cruft
	                echo -e "iface $1 inet $method" >> /etc/network/interfaces
			echo -e "$ME" >> /etc/network/interfaces
			echo -e "$BUFFERIFACES\n" >> /etc/network/interfaces

			# Re-add subsequent interfaces
			echo -e "$MORE" >> /etc/network/interfaces

		else
			# Interface not present, add it to the end
			case $1 in wlan?|ra?) echo "allow-hotplug $1" >> /etc/network/interfaces; ;; esac
			sudo echo -e "iface $1 inet $method" >> /etc/network/interfaces
			echo -e "$BUFFERIFACES\n" >> /etc/network/interfaces

		fi
		sed -i "s%#allow-hotplug.*$1%allow-hotplug $1%" /etc/network/interfaces

		# Process /etc/resolv.conf
		sed -i "/nameserver/d" /etc/resolv.conf
		echo -e "$BUFFERRESOLV" >> /etc/resolv.conf
		return 1;
	else
		return 0;
	fi
}

# List all available network interfaces
# Echoes @return
#  @1: Available interfaces
#  @2: Error code
# Returns
#  1: Success
#  0: Error
function listNetworkInterfacesFn() {
	IFACES=$(ip addr | grep state | grep -vw 'lo\|dummy[0-9]\|tun[0-9]' | cut -f 2 -d":" | sed 's/ //g' | sort);
	if [ ! -z "$IFACES" ]; then
		echo -e "$IFACES"
		return 1
	else
		return 0
	fi
}

# Check if a given string is a valid interface name
# Parameters
#  $1: Interface name
# Returns
#  1: Valid
#  0: Invalid
function isValidInterfaceFn() {
	INTERFACE=$(listNetworkInterfacesFn | grep "$1")
	if [ ! -z "$INTERFACE" ]; then
		return 1;
	else
		return 0;
	fi
}

# Reads various netowrk configuration options from related files
# Arguments
#   $1 Interface
# Return
#   1: Success
#   0: Failure
# Echoes
#   @1: Textual table
#       -----------------------
#       mode dhcp|static|manual
#	state UP|DOWN
#       ip X.X.X.X
#       netmask X.X.X:X
#       gateway X.X.X.X or None
#       nameserver1 X.X.X.X
#       nameserver2 X.X.X.X
#	protection WEP|WPA|open (only for wlan interfaces)
#	SSID XXXX (only for wlan interfaces)
#	WLANKEY XXXX (only for wlan interfaces)
#   @0: Error code
# Error codes
#   -4: Invalid interface
function readNetworkConfigurationFn() {
	isValidInterfaceFn "$1"
	if [ $? -eq 1 ]; then
		# Read network configuration from /etc/network/interfaces
		TFILEIFACES=$(cat /etc/network/interfaces | sed 's/^[ \t]*//;s/[ \t]*$//' | grep -v "^#")

		# Place everything after matching iface in a variable
		CONTENT=$(echo -e "$TFILEIFACES" | grep -A20 "^iface $1 inet" | sed '1d');

		# Delete (possible) subsequent ifaces from variable
		CONTENT=$(echo -e "$CONTENT" | sed '/iface/,$d');

		# Extract DHCP or Static
		MODE=$(echo -e "$TFILEIFACES" | sed -ne "s/\(iface $1 \)\([a-z]\{1,\}\)[\ ]\([a-z]\{1,\}\)/\3/p");
		[ -z "$MODE" ] && MODE=manual
		CIP=$(ip a show $1 | sed -n -e 's/:127\.0\.0\.1 //g' -e 's/ *inet \([0-9.]\+\).*/\1/gp');
		[ -z "$CIP" ] && CIP=$(echo -e "$CONTENT" | grep -m1 "^[ \t]*address" | awk '{print $2}');
		CSM=$(ipcalc $(ip -4 -o a show $1 | awk '{print $4}') | grep Netmask | awk '{print $2}');
		[ -z "$CSM" ] && CSM=$(ipcalc $CIP | grep Netmask | awk '{print $2}');
		CGW=$(echo -e "$CONTENT" | grep ^gateway | awk '{print $2}')
		[ -z "$CGW" ] && { if [ "$MODE" == "dhcp" ]; then CGW=$(ip route show | grep -m1 'default\|0.0.0.0' | awk '{print $3}'); else CGW="None"; fi; }

		# Extract wlan configuration
		PROTECTION=""
		MODEOPEN=$(echo -e "$CONTENT" | grep ^wireless-mode)
		MODEWPA=$(echo -e "$CONTENT" | grep ^wpa-)
		MODEWEP=$(echo -e "$CONTENT" | grep ^wireless-essid)
		if [ ! -z "$MODEOPEN" ]; then
			PROTECTION="open"
		elif [ ! -z "$MODEWPA" ]; then
			PROTECTION="WPA"
		elif [ ! -z "$MODEWEP" ]; then
			PROTECTION="WEP"
		fi

		case $1 in wlan?|ra?) [ -z "$PROTECTION" ] && PROTECTION=open;; esac

		# Extract wlan credentials
		SSID=""
		WLANKEY=""
		if [ ! -z "$PROTECTION" ]; then
			if [ "$PROTECTION" == "WEP" ]; then
				SSID=$(echo -e "$CONTENT" | sed -ne 's/wireless-essid[\ ]\(.*\)/\1/p')
				WLANKEY=$(echo -e "$CONTENT" | sed -ne 's/wireless-key[\ ]\(.*\)/\1/p')
			elif [ "$PROTECTION" == "WPA" ]; then
				SSID=$(echo -e "$CONTENT" | sed -ne 's/wpa-ssid[\ ]\(.*\)/\1/p')
				WLANKEY=$(echo -e "$CONTENT" | sed -ne 's/wpa-psk[\ ]\(.*\)/\1/p')				
			elif [ "$PROTECTION" == "open" ]; then
				SSID=$(echo -e "$CONTENT" | sed -ne 's/wireless-essid[\ ]\(.*\)/\1/p')
			fi
		fi

		# Get current state
		STATE=$(ip addr | grep state | grep "${1}:" | sed 's/.*state/state/g' | cut -f 2 -d" ")

		echo "mode $MODE"
		echo "state $STATE"
		echo "ip $CIP"
		echo "netmask $CSM"
		echo "gateway $CGW"
		DNS=(); c=1

	        # Read nameservers from /etc/resolv.conf
		while read  a b; do
		    [[ $a =~ nameserver ]] || continue
		    [ -z "$b" ] && b=$(echo $a | awk '{print $2}')
		    DNS+=("nameserver$c $b"); c=$((c+1))
		done < <(echo -e "$(grep -w nameserver  /etc/resolv.conf)")
		printf "%s\n" "${DNS[@]}"

		if [ ! -z "$PROTECTION" ]; then
			echo "protection $PROTECTION"
			if [ "$GUIMODE" -eq 1 ]; then
				echo "ssid $SSID"
				echo "key $WLANKEY"
			else
				echo "ssid $(echo $SSID | base64 --wrap=0)"
				echo "key $(echo $WLANKEY | base64 --wrap=0)"
			fi
		fi
		return 1;
	else
		return 0;
	fi
}


# Validate a given netmask
# Arguments
#  $1 Netmask
# Return
#  1: Valid
#  0: Invalid
function scanWLANNetworksFn() {
	ip link set $1 up &>/dev/null; sleep 3
	IFS=$'\n'
	OUTPUT=($(iwlist $1 scan));

	WNETWORKS=();
	WLAN=();
	NUMBERS=();
	X=-1;
	READ=0;
	for LINE in ${OUTPUT[@]}; do
		if [[ $LINE =~ "Cell" ]]; then
			if [ $READ -eq 1 ]; then
				if [ -z ${WLAN[1]} ]; then
					WLAN[1]="Open";
				fi
				if [ "${WLAN[2]}" == "on" ] && [ "${WLAN[1]}" == "Open" ]; then
					WLAN[1]="WEP";
				fi
				if [ ${#WLAN[0]} -gt 2 ]; then
					X=$(($X+1));
					WNETWORKS[$X]="${WLAN[0]},${WLAN[1]},${WLAN[2]},${WLAN[3]}";
				fi
				WLAN=();
				WLAN[1]="Open";
			fi
			READ=1;
		fi
		if [[ $LINE =~ "ESSID" ]]; then
			WLAN[0]=$(echo $LINE | cut -f2 -d":");
		fi
		if [[ $LINE =~ "WPA" ]]; then
			WLAN[1]="WPA"
		fi
		if [[ $LINE =~ "Encryption key" ]]; then
			WLAN[2]=$(echo $LINE | cut -f2 -d":");
		fi
		if [[ $LINE =~ "Signal level" ]]; then
#			WLAN[3]=$(echo $LINE | awk -F"Quality=" '{print $2}' | cut -d'/' -f1);
			WLAN[3]=$(echo $LINE | awk -F"Quality=" '{print $2}' | cut -d' ' -f1);
			[ "${WLAN[3]}" = '' ] && WLAN[3]=$(echo $LINE | awk -F"Signal level=" '{print $2}');
			[ "${WLAN[3]}" = '' ] && WLAN[3]=$(echo $LINE | awk -F"Signal level:" '{print $2}' | cut -d' ' -f1);
			[ "${WLAN[3]}" = '' ] && WLAN[3]=0
			WLAN[3]=$((100*${WLAN[3]}))
                fi
	done;
	X=$(($X+1));
	if [ ${#WLAN[0]} -gt 2 ]; then
		WNETWORKS[$X]="${WLAN[0]},${WLAN[1]},${WLAN[2]},${WLAN[3]}";
	fi
	IFS=",";
	SWITCH=1;
	while [ $SWITCH -eq 1 ]; do
		SWITCH=0;
		for((C=0;C<=$X;C++)); do
			VALUES=(${WNETWORKS[$C]});
			VALUES1=(${WNETWORKS[$(($C+1))]});
			if [[ "${VALUES1[3]}" =~ [0-9]{1,3} ]] && [[ "${VALUES[3]}" =~ [0-9]{1,3} ]]; then
				if [ ${VALUES[3]} -lt ${VALUES1[3]} ]; then
					TEMP=${WNETWORKS[$C]};
					WNETWORKS[$C]=${WNETWORKS[$(($C+1))]};
					WNETWORKS[$(($C+1))]=$TEMP;
					SWITCH=1;
				fi
			fi
		done;
	done;
	IFS=$ORIGINALIFS;
}

# Restart a (w)lan adapter
# Arguments
#  $1 Interface name
# Return
#  @: Process id of the ifup process
#  0: Process ifup not running
function restartAdapterFn() {
	[ -e /run/interfaces.xbian ] && { mv /etc/network/interfaces /etc/network/interfaces.new; mv /run/interfaces.xbian /etc/network/interfaces; }
	ifdown $1 >&/dev/null; ifdown --force $1 >&/dev/null
	for p in $(ps x | grep -wE "(dhclient|wpa_supplicant|wpa_cli).*$1" | grep -v grep | awk '{ print $1 }'); do kill -TERM "$p" &>/dev/null; done
	[ -e /etc/network/interfaces.new ] && mv /etc/network/interfaces.new /etc/network/interfaces
	nohup ifup $1 &>/tmp/ifup.out &
	PROCESSID=$!; echo $PROCESSID > /tmp/ifup.pid
	return $PROCESSID
}

# Gets the status of the (w)lan restart
# Return
#  0: The (w)lan status file does not exist
#  1: Connecting to (w)lan network
#  2: Successfully connected to network
#  3: Failed to connected to network
function getConnectStatusFn() {
	[ -n "$1" ] && ifc=$1 || ifc=XXXXXXXX
	if [ -f /tmp/ifup.out ]; then
		if grep -qwE ^"iface $1.*static|iface $1.*manual" /etc/network/interfaces && ! ip addr | grep -qw "$1.*DORMANT"; then
			STATUS=2;
		elif grep -qw "bound" /tmp/ifup.out; then
			STATUS=2;
		elif grep -qw 'No DHCPOFFERS\|Terminated\|RTNETLINK' /tmp/ifup.out; then
			STATUS=3;
		else
			STATUS=1;
		fi
	else
		STATUS=0;
	fi
	
	return $STATUS;
}

function clearStatusFn() {
	if [ -f /tmp/ifup.out ]; then
		# rm -f /tmp/ifup.out
		rm -f /tmp/ifup.pid
	fi
}

# Gets type of adapter
# Arguments
#  $1 Interface name
# Return
#  1: Adapter is WLAN
#  0: Adapter is anything else
function getAdapterTypeFn() {
	if [ ! -d "/sys/class/net/$1/wireless" ] && [ -d "/sys/class/net/$1" ]; then
		return 0;
	else
		return 1;
	fi
}	
